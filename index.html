<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"/>
<title>Polished Tetris - Exact UI</title>
<style>
  :root{
    --bg:#0f2a3a;
    --panel:#153746;
    --accent:#2b4f66;
    --soft:#0e2530;
    --glass: rgba(255,255,255,0.04);
  }
  html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Arial; background:linear-gradient(180deg,#0b2433 0%, #112d3b 100%); display:flex; align-items:center; justify-content:center;}
  /* Phone-like frame */
  .device{
    width: 420px;
    max-width:94vw;
    aspect-ratio: 9/16;
    background: linear-gradient(180deg, #142f3f 0%, #0f2733 100%);
    border-radius:28px;
    padding:20px;
    box-shadow: 0 20px 60px rgba(2,8,15,0.7), inset 0 6px 14px rgba(255,255,255,0.02);
    display:flex;
    gap:18px;
    box-sizing:border-box;
  }
  /* main board + side panel */
  .board-wrap{ display:flex; gap:18px; width:100%; height:100%; align-items:flex-start; }
  .game-frame{
    background: linear-gradient(180deg,#0b2a3a,#082022);
    border-radius:18px;
    padding:14px;
    box-shadow: inset 0 6px 14px rgba(0,0,0,0.5);
    display:flex; flex-direction:column; align-items:center;
    flex:1;
    min-width:0;
  }

  /* Canvas container to create rounded soft border like the image */
  .canvas-outer{
    background: var(--glass);
    padding:10px;
    border-radius:12px;
    box-shadow: inset 0 3px 8px rgba(0,0,0,0.6);
  }
  /* side panel */
  .side{
    width:145px;
    background:linear-gradient(180deg,#153746,#122d36);
    border-radius:18px;
    padding:18px 14px;
    box-sizing:border-box;
    color:#e6f6fb;
    display:flex;
    flex-direction:column;
    align-items:stretch;
    justify-content:flex-start;
    gap:18px;
  }
  .side h3{ margin:0; font-size:14px; letter-spacing:1px; color:#dff6ff; text-align:center;}
  .preview{
    background: linear-gradient(180deg,#0e2a36,#0a232a);
    border-radius:10px;
    padding:8px;
    display:flex;
    align-items:center;
    justify-content:center;
  }
  .score{
    text-align:center;
    font-weight:700;
    font-size:34px;
    margin-top:8px;
    color:#eaf7fb;
  }
  /* Control buttons area below board */
  .controls{ display:flex; gap:10px; margin-top:auto; align-items:center; justify-content:center; width:100%;}
  .btn{
    width:66px;height:66px;border-radius:50%;
    background:linear-gradient(180deg,#0f3442,#0b2530);
    border: none; color:white; font-size:20px;
    display:flex;align-items:center;justify-content:center;
    box-shadow: 0 8px 18px rgba(2,8,15,0.6), inset 0 4px 10px rgba(255,255,255,0.02);
    -webkit-tap-highlight-color: transparent;
  }
  .side-controls{ display:flex; flex-direction:column; gap:18px; align-items:center; }
  .side-controls .btn.small{ width:66px;height:66px; font-size:18px; }
  /* small arrow icons */
  .arrow{width:18px;height:18px;opacity:0.95; filter:drop-shadow(0 2px 2px rgba(0,0,0,0.6));}
  /* bottom row icons smaller */
  .btn.icon-only{ width:56px;height:56px; }

  /* responsive tweaks */
  @media (max-width:480px){
    .device{ padding:14px; border-radius:18px; gap:10px;}
    .side{ width:120px; padding:12px;}
    .btn{ width:58px; height:58px; }
  }

  /* overlay for Game Over */
  .overlay{
    position:absolute;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    pointer-events:none;
  }
  .overlay .panel{
    background: rgba(10,18,22,0.6);
    border-radius:12px;
    padding:18px 22px;
    color:#ffffff;
    font-weight:700;
    display:none;
    pointer-events:auto;
  }
  .overlay.show .panel{ display:block; }
  /* small label */
  .label { font-size:12px; color:#cfeff7; text-align:center; letter-spacing:0.6px; }
</style>
</head>
<body>

<div class="device" id="device">
  <div class="board-wrap">
    <div class="game-frame" id="gameFrame" style="position:relative;">
      <div class="canvas-outer">
        <!-- Main board canvas: size will be set by JS for crispness -->
        <canvas id="board"></canvas>
      </div>

      <div class="controls" style="margin-top:12px;">
        <button class="btn icon-only" id="leftBtn" aria-label="left">
          <!-- left arrow -->
          <svg class="arrow" viewBox="0 0 24 24" fill="none"><path d="M15 18L9 12l6-6" stroke="#dff6ff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
        </button>
        <button class="btn" id="rotateBtn" aria-label="rotate">
          <!-- rotate icon -->
          <svg class="arrow" viewBox="0 0 24 24" fill="none"><path d="M21 12a9 9 0 10-3.29 6.42" stroke="#dff6ff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M21 12v6h-6" stroke="#dff6ff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
        </button>
        <button class="btn icon-only" id="rightBtn" aria-label="right">
          <!-- right arrow -->
          <svg class="arrow" viewBox="0 0 24 24" fill="none"><path d="M9 18l6-6-6-6" stroke="#dff6ff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
        </button>
        <button class="btn icon-only" id="downBtn" aria-label="soft-drop">
          <svg class="arrow" viewBox="0 0 24 24" fill="none"><path d="M12 5v14M5 12l7 7 7-7" stroke="#dff6ff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
        </button>
      </div>

      <!-- overlay for Game Over / Pause -->
      <div class="overlay" id="overlay" style="top:0;">
        <div class="panel" id="overlayPanel">GAME OVER — Tap restart to play again</div>
      </div>
    </div>

    <div class="side">
      <div style="display:flex;justify-content:center;">
        <h3>NEXT</h3>
      </div>
      <div class="preview">
        <canvas id="next" width="120" height="120" style="display:block;"></canvas>
      </div>

      <div style="display:flex;flex-direction:column;align-items:center;">
        <div class="label">SCORE</div>
        <div class="score" id="score">0</div>
      </div>

      <div style="display:flex;flex-direction:column;align-items:center;">
        <div class="label">LEVEL</div>
        <div style="font-weight:700;font-size:20px;margin-top:6px;color:#eaf7fb" id="level">0</div>
      </div>

      <div style="margin-top:auto;display:flex;flex-direction:column;align-items:center;gap:12px;">
        <button class="btn small" id="hardDropBtn" title="Hard Drop">
          <svg class="arrow" viewBox="0 0 24 24" fill="none"><path d="M12 2v14" stroke="#dff6ff" stroke-width="2" stroke-linecap="round"/><path d="M5 9l7 7 7-7" stroke="#dff6ff" stroke-width="2" stroke-linecap="round"/></svg>
        </button>
        <button class="btn small" id="restartBtn" title="Restart">⟲</button>
      </div>
    </div>
  </div>
</div>

<script>
/* ---------- Configuration ---------- */
const COLS = 10;
const ROWS = 20;
const BASE_CELL = 28; // base visual cell size (will scale to fit device if needed)
const COLORS = {
  0: null,
  1: '#ff4d6d', // red
  2: '#00c2ff', // cyan
  3: '#00d25b', // green
  4: '#9b6bff', // purple
  5: '#ffb85c', // orange
  6: '#ffe86b', // yellow
  7: '#0077ff'  // blue-like
};
const SCORE_TABLE = {1:100, 2:300, 3:500, 4:800};

/* ---------- Canvas setup (crisp on retina) ---------- */
const boardCanvas = document.getElementById('board');
const ctx = boardCanvas.getContext('2d');
const nextCanvas = document.getElementById('next');
const nctx = nextCanvas.getContext('2d');

function setupSizes(){
  // compute available height for main canvas so device aspect fits nicely
  const device = document.getElementById('device');
  const rect = device.getBoundingClientRect();

  // compute target board pixel size based on available real estate: give priority to rows
  const desiredCell = BASE_CELL;
  const width = COLS * desiredCell;
  const height = ROWS * desiredCell;

  // fit into left container while keeping side panel width stable
  const boardArea = document.querySelector('.game-frame');
  const outerStyle = getComputedStyle(boardArea);
  const padTop = parseInt(outerStyle.paddingTop);
  const padBottom = parseInt(outerStyle.paddingBottom);

  const maxH = rect.height - 80; // leave room for controls & side spacing
  const maxW = rect.width - 170; // leave room for side panel and gaps
  const scale = Math.min(maxW / width, maxH / height, 1);

  const displayWidth = Math.round(width * scale);
  const displayHeight = Math.round(height * scale);

  // devicePixelRatio handling
  const ratio = Math.max(window.devicePixelRatio || 1, 1);
  boardCanvas.style.width = displayWidth + 'px';
  boardCanvas.style.height = displayHeight + 'px';
  boardCanvas.width = displayWidth * ratio;
  boardCanvas.height = displayHeight * ratio;
  ctx.setTransform(ratio,0,0,ratio,0,0);

  // next canvas fit
  const nextSize = Math.round(desiredCell * 4 * scale);
  nextCanvas.style.width = nextSize+'px';
  nextCanvas.style.height = nextSize+'px';
  nextCanvas.width = nextSize * ratio;
  nextCanvas.height = nextSize * ratio;
  nctx.setTransform(ratio,0,0,ratio,0,0);

  // store cell pixel size
  render.cellSize = desiredCell * scale;
}
window.addEventListener('resize', setupSizes);

/* ---------- Utilities ---------- */
function createMatrix(w,h){
  const m = [];
  for(let y=0;y<h;y++){
    m.push(new Array(w).fill(0));
  }
  return m;
}
function randomPiece(){
  const pieces='TJLOSZI';
  return pieces[Math.floor(Math.random()*pieces.length)];
}
function cloneMatrix(m){
  return m.map(row=>row.slice());
}

/* ---------- Pieces ---------- */
function pieceFromType(type){
  switch(type){
    case 'T': return [[0,0,0],[1,1,1],[0,1,0]].map(r=>r.slice());
    case 'O': return [[2,2],[2,2]].map(r=>r.slice());
    case 'L': return [[0,3,0],[0,3,0],[0,3,3]].map(r=>r.slice());
    case 'J': return [[0,4,0],[0,4,0],[4,4,0]].map(r=>r.slice());
    case 'I': return [[0,5,0,0],[0,5,0,0],[0,5,0,0],[0,5,0,0]].map(r=>r.slice());
    case 'S': return [[0,6,6],[6,6,0],[0,0,0]].map(r=>r.slice());
    case 'Z': return [[7,7,0],[0,7,7],[0,0,0]].map(r=>r.slice());
    default: return [[0]];
  }
}

/* ---------- Game State ---------- */
let arena = createMatrix(COLS, ROWS);
let player = {
  pos:{x:0,y:0},
  matrix:null,
};
let next = { matrix: pieceFromType(randomPiece()) };
let score = 0;
let level = 0;
let linesCleared = 0;

let dropIntervalBase = 1000; // ms for level 0
let dropInterval = dropIntervalBase;
let dropCounter = 0;
let lastTime = 0;
let gameOver = false;
let paused = false;

/* ---------- Collision / Merge / Sweep ---------- */
function collide(arena, player){
  const m = player.matrix;
  const o = player.pos;
  for(let y=0;y<m.length;y++){
    for(let x=0;x<m[y].length;x++){
      if (m[y][x] !== 0){
        const ay = y + o.y;
        const ax = x + o.x;
        // if outside top/left/right/bottom treat as collision
        if (ay < 0 || ax < 0 || ax >= COLS || ay >= ROWS) return true;
        if (arena[ay][ax] !== 0) return true;
      }
    }
  }
  return false;
}
function merge(arena, player){
  player.matrix.forEach((row,y)=>{
    row.forEach((val,x)=>{
      if (val !== 0){
        arena[y + player.pos.y][x + player.pos.x] = val;
      }
    });
  });
}
function arenaSweep(){
  let rowCount = 0;
  outer: for(let y = ROWS - 1; y >= 0; --y){
    for(let x = 0; x < COLS; ++x){
      if (arena[y][x] === 0) continue outer;
    }
    // full row
    const row = arena.splice(y,1)[0].fill(0);
    arena.unshift(row);
    ++rowCount;
    ++y; // re-check same index after unshift
  }
  if (rowCount > 0) {
    linesCleared += rowCount;
    // Score via standard scheme scaled by level+1
    const gained = (SCORE_TABLE[rowCount] || rowCount * 100) * (level + 1);
    score += gained;
    // level up every 10 lines (configurable)
    const newLevel = Math.floor(linesCleared / 10);
    if (newLevel !== level){
      level = newLevel;
      dropInterval = Math.max(120, dropIntervalBase - level * 80); // lower bound
    }
    updateUI();
  }
}

/* ---------- Rotation with wall-kicks (simple) ---------- */
function rotateMatrix(m, dir){
  // transpose
  for(let y=0;y<m.length;y++){
    for(let x=0;x<y;x++){
      [m[x][y], m[y][x]] = [m[y][x], m[x][y]];
    }
  }
  if (dir > 0) m.forEach(row => row.reverse());
  else m.reverse();
}
function playerRotate(dir){
  const prev = cloneMatrix(player.matrix);
  rotateMatrix(player.matrix, dir);
  // wallkick offsets to try (0, -1, +1, -2, +2)
  const offsets = [0, -1, 1, -2, 2];
  let kicked = false;
  for(let i=0;i<offsets.length;i++){
    player.pos.x += offsets[i];
    if (!collide(arena, player)){
      kicked = true; break;
    }
    player.pos.x -= offsets[i];
  }
  if (!kicked){
    // also try moving up 1 (rare)
    player.pos.y -= 1;
    if (!collide(arena, player)) kicked = true;
    else player.pos.y += 1;
  }
  if (!kicked){
    // revert rotation if all attempts fail
    player.matrix = prev;
  }
}

/* ---------- Player actions ---------- */
function playerDrop(){
  player.pos.y++;
  if (collide(arena, player)){
    player.pos.y--;
    merge(arena, player);
    arenaSweep();
    playerReset();
    if (collide(arena, player)){ // if spawning collides -> game over
      endGame();
    }
  }
  dropCounter = 0;
}
function playerMove(offset){
  player.pos.x += offset;
  if (collide(arena, player)) player.pos.x -= offset;
}
function hardDrop(){
  while(!collide(arena, player)){
    player.pos.y++;
  }
  player.pos.y--;
  merge(arena, player);
  arenaSweep();
  playerReset();
  if (collide(arena, player)) endGame();
  dropCounter = 0;
}

/* ---------- Reset / spawn ---------- */
function playerReset(){
  // move next into player, create a new next
  player.matrix = pieceFromType(getAndReplaceNext());
  // center horizontally
  player.pos.y = 0;
  player.pos.x = Math.floor((COLS - player.matrix[0].length) / 2);
}

/* generate initial next first. we ensure next exists before first reset */
function getAndReplaceNext(){
  if (!next.matrix) next.matrix = pieceFromType(randomPiece());
  const type = detectTypeFromMatrix(next.matrix);
  next.matrix = pieceFromType(randomPiece());
  return type;
}
function detectTypeFromMatrix(m){
  // deduce piece by shape by matching sample matrices
  const samples = { T: pieceFromType('T'), O: pieceFromType('O'), L: pieceFromType('L'),
                    J: pieceFromType('J'), I: pieceFromType('I'), S: pieceFromType('S'), Z: pieceFromType('Z') };
  for(const k in samples){
    if (matEqual(samples[k], m)) return k;
  }
  // fallback: pick random char if unknown
  return randomPiece();
}
function matEqual(a,b){
  if (!a || !b) return false;
  if (a.length !== b.length) return false;
  for(let y=0;y<a.length;y++){
    if (a[y].length !== b[y].length) return false;
    for(let x=0;x<a[y].length;x++){
      if (a[y][x] !== b[y][x]) return false;
    }
  }
  return true;
}

/* ---------- UI & Rendering ---------- */
const render = { cellSize: BASE_CELL, gridColor: 'rgba(255,255,255,0.03)' };

function roundRect(ctx, x, y, w, h, r){
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y, x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x, y+h, r);
  ctx.arcTo(x, y+h, x, y, r);
  ctx.arcTo(x, y, x+w, y, r);
  ctx.closePath();
}
function drawCell(ctx, x, y, color, cell){
  const cs = cell;
  const px = x * cs;
  const py = y * cs;
  const corner = Math.max(3, cs*0.14);
  // shadow/background block
  ctx.save();
  // draw main rounded box with gradient
  roundRect(ctx, px+1, py+1, cs-2, cs-2, corner);
  const grad = ctx.createLinearGradient(px, py, px + cs, py + cs);
  grad.addColorStop(0, lighten(color, 0.10));
  grad.addColorStop(0.5, color);
  grad.addColorStop(1, darken(color, 0.07));
  ctx.fillStyle = grad;
  ctx.fill();
  // inner glossy highlight
  ctx.globalCompositeOperation = 'overlay';
  ctx.beginPath();
  ctx.moveTo(px + cs*0.12, py + cs*0.08);
  ctx.quadraticCurveTo(px + cs*0.5, py + cs*0.18, px + cs*0.88, py + cs*0.08);
  ctx.lineTo(px + cs*0.88, py + cs*0.36);
  ctx.quadraticCurveTo(px + cs*0.5, py + cs*0.48, px + cs*0.12, py + cs*0.36);
  ctx.closePath();
  ctx.fillStyle = "rgba(255,255,255,0.12)";
  ctx.fill();
  // inner shadow
  ctx.globalCompositeOperation = 'multiply';
  ctx.fillStyle = "rgba(0,0,0,0.12)";
  roundRect(ctx, px+2, py+2, cs-4, cs-4, corner-1);
  ctx.fill();
  ctx.restore();
}

// lighten/darken helper
function lighten(hex, amt){
  const c = hexToRgb(hex);
  return `rgb(${Math.min(255, Math.round(c.r + 255*amt))},${Math.min(255, Math.round(c.g + 255*amt))},${Math.min(255, Math.round(c.b + 255*amt))})`;
}
function darken(hex, amt){
  const c = hexToRgb(hex);
  return `rgb(${Math.max(0, Math.round(c.r * (1-amt)))},${Math.max(0, Math.round(c.g * (1-amt)))},${Math.max(0, Math.round(c.b * (1-amt)))})`;
}
function hexToRgb(hex){
  const h = hex.replace('#','');
  return { r: parseInt(h.substring(0,2),16), g: parseInt(h.substring(2,4),16), b: parseInt(h.substring(4,6),16) };
}

function drawGridBackground(){
  const cs = render.cellSize;
  const w = COLS * cs, h = ROWS * cs;
  // subtle tile background
  ctx.fillStyle = '#03161b';
  ctx.fillRect(0,0,w,h);
  // grid lines
  ctx.strokeStyle = render.gridColor;
  ctx.lineWidth = 1;
  for(let x=0;x<=COLS;x++){
    const px = x * cs + 0.5;
    ctx.beginPath();
    ctx.moveTo(px,0); ctx.lineTo(px,h); ctx.stroke();
  }
  for(let y=0;y<=ROWS;y++){
    const py = y * cs + 0.5;
    ctx.beginPath();
    ctx.moveTo(0,py); ctx.lineTo(w,py); ctx.stroke();
  }
}

function draw(){
  // main board
  const cs = render.cellSize;
  ctx.clearRect(0,0, boardCanvas.width, boardCanvas.height);
  drawGridBackground();
  // draw merged arena
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      const v = arena[y][x];
      if (v !== 0){
        drawCell(ctx, x, y, COLORS[v], cs);
      }
    }
  }
  // draw current player piece
  if (player.matrix){
    for(let y=0;y<player.matrix.length;y++){
      for(let x=0;x<player.matrix[y].length;x++){
        const v = player.matrix[y][x];
        if (v !== 0){
          drawCell(ctx, x + player.pos.x, y + player.pos.y, COLORS[v], cs);
        }
      }
    }
  }

  // next preview
  drawNext();
}

function drawNext(){
  const cs = render.cellSize * Math.min(1, 120 / (render.cellSize*4)); // scale to fit next canvas nicely
  nctx.clearRect(0,0, nextCanvas.width, nextCanvas.height);
  nctx.fillStyle = '#031a20';
  nctx.fillRect(0,0,nextCanvas.width, nextCanvas.height);

  // center the shape within next canvas: compute bounding box
  const m = next.matrix || [[0]];
  const rows = m.length, cols = m[0].length;
  const offsetX = Math.round((nextCanvas.width/ (window.devicePixelRatio || 1) - cols*cs)/2);
  const offsetY = Math.round((nextCanvas.height/ (window.devicePixelRatio || 1) - rows*cs)/2);
  // draw grid background inside preview (subtle)
  nctx.save();
  nctx.translate(offsetX, offsetY);
  for(let y=0;y<rows;y++){
    for(let x=0;x<cols;x++){
      const v = m[y][x];
      if (v !== 0) {
        // use same drawCell but adapted to nctx (create helper)
        drawCellOnCtx(nctx, x, y, COLORS[v], cs);
      }
    }
  }
  nctx.restore();
}

function drawCellOnCtx(context, x, y, color, cs){
  const px = x * cs;
  const py = y * cs;
  context.save();
  // rounded shape
  const r = Math.max(3, cs*0.14);
  context.beginPath();
  context.moveTo(px+r, py);
  context.arcTo(px+cs, py, px+cs, py+cs, r);
  context.arcTo(px+cs, py+cs, px, py+cs, r);
  context.arcTo(px, py+cs, px, py, r);
  context.arcTo(px, py, px+cs, py, r);
  context.closePath();
  const grad = context.createLinearGradient(px, py, px+cs, py+cs);
  grad.addColorStop(0, lighten(color, 0.10));
  grad.addColorStop(0.5, color);
  grad.addColorStop(1, darken(color, 0.07));
  context.fillStyle = grad;
  context.fill();
  // glossy highlight
context.globalCompositeOperation = 'overlay';
  context.beginPath();
  context.moveTo(px + cs*0.12, py + cs*0.08);
  context.quadraticCurveTo(px + cs*0.5, py + cs*0.18, px + cs*0.88, py + cs*0.08);
  context.lineTo(px + cs*0.88, py + cs*0.36);
  context.quadraticCurveTo(px + cs*0.5, py + cs*0.48, px + cs*0.12, py + cs*0.36);
  context.closePath();
  context.fillStyle = "rgba(255,255,255,0.12)";
  context.fill();
  context.restore();
}

/* ---------- UI update ---------- */
function updateUI(){
  document.getElementById('score').textContent = score;
  document.getElementById('level').textContent = level;
}

/* ---------- Game loop ---------- */
function update(time = 0){
  if (paused || gameOver) return; // stop loop on end/pause
  const delta = time - lastTime;
  lastTime = time;
  dropCounter += delta;
  if (dropCounter > dropInterval){
    playerDrop();
  }
  draw();
  requestAnimationFrame(update);
}

/* ---------- Game start / end ---------- */
function startGame(){
  arena = createMatrix(COLS, ROWS);
  score = 0; level = 0; linesCleared = 0;
  dropInterval = dropIntervalBase;
  gameOver = false;
paused = false;
  next.matrix = pieceFromType(randomPiece());
  // ensure first player piece exists without collision
  player.matrix = pieceFromType(getAndReplaceNext());
  player.pos = { x: Math.floor((COLS - player.matrix[0].length)/2), y: 0 };
  updateUI();
  document.getElementById('overlay').classList.remove('show');
  lastTime = performance.now();
  requestAnimationFrame(update);
}

function endGame(){
  gameOver = true;
  const overlay = document.getElementById('overlay');
  overlay.classList.add('show');
  const panel = document.getElementById('overlayPanel');
  panel.textContent = `GAME OVER — Score ${score}`;
}

/* ---------- Input handling ---------- */
document.addEventListener('keydown', (e)=>{
  if (gameOver) return;
if (e.key === 'ArrowLeft'){ playerMove(-1); draw(); }
  else if (e.key === 'ArrowRight'){ playerMove(1); draw(); }
  else if (e.key === 'ArrowDown'){ playerDrop(); draw(); }
  else if (e.key === 'ArrowUp' || e.key === 'x'){ playerRotate(1); draw(); }
  else if (e.key === 'z'){ playerRotate(-1); draw(); }
  else if (e.key === ' '){ e.preventDefault(); hardDrop(); draw(); }
  else if (e.key.toLowerCase() === 'p'){ paused = !paused; if (!paused) { lastTime = performance.now(); requestAnimationFrame(update);} }
});

function setupButtons(){
  document.getElementById('leftBtn').addEventListener('touchstart', e=>{ e.preventDefault(); playerMove(-1); draw(); });
  document.getElementById('rightBtn').addEventListener('touchstart', e=>{ e.preventDefault(); playerMove(1); draw(); });
  document.getElementById('downBtn').addEventListener('touchstart', e=>{ e.preventDefault(); playerDrop(); draw(); });
  document.getElementById('rotateBtn').addEventListener('touchstart', e=>{ e.preventDefault(); playerRotate(1); draw(); });
  document.getElementById('hardDropBtn').addEventListener('touchstart', e=>{ e.preventDefault(); hardDrop(); draw(); });

  // also support mouse clicks for desktop
  document.getElementById('leftBtn').addEventListener('click', ()=>{ playerMove(-1); draw(); });
  document.getElementById('rightBtn').addEventListener('click', ()=>{ playerMove(1); draw(); });
  document.getElementById('downBtn').addEventListener('click', ()=>{ playerDrop(); draw(); });
  document.getElementById('rotateBtn').addEventListener('click', ()=>{ playerRotate(1); draw(); });
  document.getElementById('hardDropBtn').addEventListener('click', ()=>{ hardDrop(); draw(); });
document.getElementById('restartBtn').addEventListener('click', ()=>{
    startGame();
  });
}

/* ---------- Init ---------- */
setupSizes();
setupButtons();
updateUI();
startGame();

/* handle initial canvas sizing changes after fonts/layout stabilized */
setTimeout(()=>{ setupSizes(); draw(); }, 120);
</script>

</body>
</html>

